<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://zzy896.github.io/my-blogs/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/my-blogs/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/my-blogs/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/my-blogs/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/my-blogs/">Home</a>
        
          <a class="main-nav-link" href="/my-blogs/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/my-blogs/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://zzy896.github.io/my-blogs"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Java知识总结之——Type" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2021/06/02/Java知识总结之——Type/" class="article-date">
  <time datetime="2021-06-02T06:13:56.000Z" itemprop="datePublished">2021-06-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2021/06/02/Java知识总结之——Type/">Java知识总结之——Type</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Type是Java 编程语言中所有类型的公共高级接口（官方解释），也就是Java中所有类型的“爹”,它并不是我们平常工作中经常使用的 int、String、List、Map等数据类型，而是从Java语言角度来说，对基本类型、引用类型向上的抽象；</p>
<p><strong><em>Type体系中类型的包括：</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.原始类型(Type):不仅仅包含我们平常所指的类，还包括枚举、数组、注解等</span><br><span class="line">2.参数化类型(ParameterizedType):就是我们平常所用到的泛型List&lt;String&gt;、Map&lt;K,V&gt;,Set&lt;T&gt;,Class&lt;?&gt;</span><br><span class="line">3.数组类型(GenericArrayType):并不是我们工作中所使用的数组String[] 、byte[]，而是带有泛型的数组，即T[]</span><br><span class="line">4.类型变量(TypeVariable):比如 T a</span><br><span class="line">5.基本类型(Class):原始类型，每个类(貌似接口也有)都会有个Class对象</span><br></pre></td></tr></table></figure></p>
<p><strong><em>Type及相关类所在包位置：java.lang.reflect</em></strong><br>Type类几乎在各种框架中都能看到，尤其是涉及代理，反射的业务。理解好Type类也会对今后框架封装，源码解读有很大好处。</p>
<p><strong>1.Type</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface Type &#123;</span><br><span class="line">    /**</span><br><span class="line">     * Returns a string describing this <span class="built_in">type</span>, including information</span><br><span class="line">     * about any <span class="built_in">type</span> parameters.</span><br><span class="line">     *</span><br><span class="line">     * @implSpec The default implementation calls &#123;@code toString&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @<span class="built_in">return</span> a string describing this <span class="built_in">type</span></span><br><span class="line">     * @since 1.8</span><br><span class="line">     */</span><br><span class="line">    default String <span class="function"><span class="title">getTypeName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从java1.8开始，type默认有个getTypeName()方法</p>
<p><strong>2.ParameterizedType</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface ParameterizedType extends Type &#123;</span><br><span class="line">    // 获取&lt;&gt;中实际的类型参数，以Type数组形式返回</span><br><span class="line">    Type[] getActualTypeArguments();</span><br><span class="line">    // 获取&lt;&gt;前面的类型</span><br><span class="line">    Type getRawType();</span><br><span class="line">    // 如果这个类型是某个类型所属，则获取这个所有者的类型，否则返回null,比如Map.Entry&lt;Sting,String&gt;，会返回Map</span><br><span class="line">    Type getOwnerType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.TypeVariable</strong><br>类型变量，即泛型中的变量；例如：T、K、V等变量，可以表示任何类；在这需要强调的是，TypeVariable代表着泛型中的变量，而ParameterizedType则代表整个泛型；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public interface TypeVariable&lt;D extends GenericDeclaration&gt; extends Type, AnnotatedElement &#123;</span><br><span class="line">    // 获取泛型的上限，无显示定义(extends),默认为Object</span><br><span class="line">    Type[] getBounds();</span><br><span class="line">    // 获取声明改类型变量实体(即获取类，方法或构造器名)</span><br><span class="line">    D getGenericDeclaration();</span><br><span class="line">    // 获取名称，即K、V、E之类名称</span><br><span class="line">    String getName();</span><br><span class="line">    // </span><br><span class="line">     AnnotatedType[] getAnnotatedBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4. GenericArrayType</strong><br>泛型数组类型，用来描述ParameterizedType、TypeVariable类型的数组；即List<t>[] 、T[]等<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface GenericArrayType extends Type &#123;</span><br><span class="line">    // 获得这个数组元素类型，比如T[]  则获得T的<span class="built_in">type</span></span><br><span class="line">    Type getGenericComponentType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<p><strong>5.Class</strong><br>与上三种不同，Class是Type的一个实现类，属于原始类型，是Java反射的基础，对java类的的抽象。在程序运行期间，每一个类都对应一个Class对象，这个对象包含了类的修饰符、方法、属性、构造等信息，所以我们可以对这个Class对象进行相应的操作，这就是Java的反射。</p>
<p><strong>6.WildcardType</strong><br>泛型表达式（或者通配符表达式），即? extends Number这样的表达式;WildcardType虽然是Type的子接口，但却不是Java类型中的一种：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface WildcardType extends Type &#123;</span><br><span class="line">    // 获取泛型表达式上界（上限extends）</span><br><span class="line">    Type[] getUpperBounds();</span><br><span class="line">    // 获取泛型表达式下界（下限super）</span><br><span class="line">    Type[] getLowerBounds();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>7.各种Type测试</strong><br><strong><strong>7.1 ParameterizedType</strong></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        // 获取ParameterizedTypeTest类的list属性</span><br><span class="line">        Field fieldList = ParameterizedTypeTest.class.getDeclaredField(<span class="string">"list"</span>);</span><br><span class="line">        // 获取该属性的泛型类型</span><br><span class="line">        Type typeList = fieldList.getGenericType();</span><br><span class="line">        System.out.println(<span class="string">"list域类型名："</span>+typeList.getTypeName());</span><br><span class="line">        System.out.println(<span class="string">"list域实际的Type类型："</span>+typeList.getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">".........................................................\n"</span>);</span><br><span class="line"></span><br><span class="line">        // 获取ParameterizedTypeTest类的list属性</span><br><span class="line">        Field fieldSet = ParameterizedTypeTest.class.getDeclaredField(<span class="string">"set"</span>);</span><br><span class="line">        // 获取该属性的泛型类型</span><br><span class="line">        Type typeSet = fieldSet.getGenericType();</span><br><span class="line">        System.out.println(<span class="string">"set域类型名："</span>+typeSet.getTypeName());</span><br><span class="line">        System.out.println(<span class="string">"set域实际的Type类型："</span>+typeSet.getClass().getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">".........................................................\n"</span>);</span><br><span class="line">        // 获取ParameterizedTypeTest类的list属性</span><br><span class="line">        Field fieldMap = ParameterizedTypeTest.class.getDeclaredField(<span class="string">"map"</span>);</span><br><span class="line">        // 获取该属性的泛型类型</span><br><span class="line">        Type typeMap = fieldMap.getGenericType();</span><br><span class="line">        System.out.println(<span class="string">"map域类型名："</span>+typeMap.getTypeName());</span><br><span class="line">        System.out.println(<span class="string">"map域实际的Type类型："</span>+typeMap.getClass().getName());</span><br><span class="line">        <span class="keyword">if</span> (typeMap instanceof ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType mapParameterizedType = (ParameterizedType) typeMap;</span><br><span class="line">            // 获取泛型中的实际参数</span><br><span class="line">            Type[] types = mapParameterizedType.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">"map域泛型参数类型[0]:"</span>+types[0]);</span><br><span class="line">            System.out.println(<span class="string">"map域泛型参数类型[1]:"</span>+types[1]);</span><br><span class="line">            System.out.println(<span class="string">"map域声明泛型参数的类类型："</span>+mapParameterizedType.getRawType());</span><br><span class="line">            System.out.println(<span class="string">"泛型的拥有者类型："</span>+mapParameterizedType.getOwnerType());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">".........................................................\n"</span>);</span><br><span class="line">        // 获取ParameterizedTypeTest类的list属性</span><br><span class="line">        Field fieldMap2 = ParameterizedTypeTest.class.getDeclaredField(<span class="string">"map2"</span>);</span><br><span class="line">        // 获取该属性的泛型类型</span><br><span class="line">        Type typeMap2 = fieldMap2.getGenericType();</span><br><span class="line">        System.out.println(<span class="string">"map2域类型名："</span>+typeMap2.getTypeName());</span><br><span class="line">        System.out.println(<span class="string">"map2域实际的Type类型："</span>+typeMap2.getClass().getName());</span><br><span class="line">        <span class="keyword">if</span> (typeMap2 instanceof ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType mapParameterizedType2 = (ParameterizedType) typeMap2;</span><br><span class="line">            // 获取泛型中的实际参数</span><br><span class="line">            Type[] types = mapParameterizedType2.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">"map2域泛型参数类型[0]:"</span>+types[0]);</span><br><span class="line">            System.out.println(<span class="string">"map2域泛型参数类型[1]:"</span>+types[1]);</span><br><span class="line">            System.out.println(<span class="string">"map2域声明泛型参数的类类型："</span>+mapParameterizedType2.getRawType());</span><br><span class="line">            System.out.println(<span class="string">"泛型的拥有者类型："</span>+mapParameterizedType2.getOwnerType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class ParameterizedTypeTest&lt;T&gt;&#123;</span><br><span class="line">        private List&lt;T&gt; list = null;</span><br><span class="line">        private Set&lt;T&gt;  <span class="built_in">set</span> = null;</span><br><span class="line">        private Map&lt;String ,T&gt; map = null;</span><br><span class="line">        private Map.Entry&lt;String,Integer&gt;  map2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>测试结果：</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">list域类型名：java.util.List&lt;T&gt;</span><br><span class="line">list域实际的Type类型：sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">.........................................................</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>域类型名：java.util.Set&lt;T&gt;</span><br><span class="line"><span class="built_in">set</span>域实际的Type类型：sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">.........................................................</span><br><span class="line"></span><br><span class="line">map域类型名：java.util.Map&lt;java.lang.String, T&gt;</span><br><span class="line">map域实际的Type类型：sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">map域泛型参数类型[0]:class java.lang.String</span><br><span class="line">map域泛型参数类型[1]:T</span><br><span class="line">map域声明泛型参数的类类型：interface java.util.Map</span><br><span class="line">泛型的拥有者类型：null</span><br><span class="line">.........................................................</span><br><span class="line"></span><br><span class="line">map2域类型名：java.util.Map<span class="variable">$Entry</span>&lt;java.lang.String, java.lang.Integer&gt;</span><br><span class="line">map2域实际的Type类型：sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">map2域泛型参数类型[0]:class java.lang.String</span><br><span class="line">map2域泛型参数类型[1]:class java.lang.Integer</span><br><span class="line">map2域声明泛型参数的类类型：interface java.util.Map<span class="variable">$Entry</span></span><br><span class="line">泛型的拥有者类型：interface java.util.Map</span><br></pre></td></tr></table></figure></p>
<p><strong><strong>7.2 GenericArrayType</strong></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        Field fieldListArray = GenericArrayTypeTest.class.getDeclaredField(<span class="string">"lists"</span>);</span><br><span class="line">        Type typeListArray = fieldListArray.getGenericType();</span><br><span class="line">        System.out.println(<span class="string">"lists域Type类型："</span>+typeListArray.getClass().getName());</span><br><span class="line">        GenericArrayType genericArrayType1 = (GenericArrayType) typeListArray;</span><br><span class="line">        System.out.println(<span class="string">"lists域元素类型:"</span>+genericArrayType1.getGenericComponentType());</span><br><span class="line">        System.out.println(<span class="string">"lists域元素Type类型:"</span>+genericArrayType1.getGenericComponentType().getClass().getName());</span><br><span class="line">        System.out.println(<span class="string">"......................................................\n"</span>);</span><br><span class="line"></span><br><span class="line">        Field fieldT = GenericArrayTypeTest.class.getDeclaredField(<span class="string">"t"</span>);</span><br><span class="line">        Type typeT = fieldT.getGenericType();</span><br><span class="line">        System.out.println(<span class="string">"t域Type类型："</span>+typeT.getClass().getName());</span><br><span class="line">        GenericArrayType genericArrayType2 = (GenericArrayType) typeT;</span><br><span class="line">        System.out.println(<span class="string">"t域元素类型:"</span>+genericArrayType2.getGenericComponentType());</span><br><span class="line">        System.out.println(<span class="string">"t域元素Type类型:"</span>+genericArrayType2.getGenericComponentType().getClass().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static class GenericArrayTypeTest&lt;T&gt;&#123;</span><br><span class="line">        private T[] t;</span><br><span class="line">        private List&lt;String&gt;[] lists;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>执行结果：</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lists域Type类型：sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl</span><br><span class="line">lists域元素类型:java.util.List&lt;java.lang.String&gt;</span><br><span class="line">lists域元素Type类型:sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">......................................................</span><br><span class="line"></span><br><span class="line">t域Type类型：sun.reflect.generics.reflectiveObjects.GenericArrayTypeImpl</span><br><span class="line">t域元素类型:T</span><br><span class="line">t域元素Type类型:sun.reflect.generics.reflectiveObjects.TypeVariableImpl</span><br></pre></td></tr></table></figure></p>
<p><strong><strong>7.3 TypeVariable</strong></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        Field aField = TypeVariableTest.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">        Type aFieldType = aField.getGenericType();</span><br><span class="line">        Class aFieldClass = aField.getType();</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest&lt;T&gt; a 域 type名："</span>+aFieldType.getTypeName());</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest&lt;T&gt; a 域 type的class名："</span>+aFieldType.getClass().getCanonicalName());</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest&lt;T&gt; a 域 Class名: "</span>+aFieldClass.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aFieldType instanceof TypeVariable)&#123;</span><br><span class="line">            TypeVariable typeVariable = (TypeVariable) aFieldType;</span><br><span class="line">            String name = typeVariable.getName();</span><br><span class="line">            Type[] bounds = typeVariable.getBounds();</span><br><span class="line">            System.out.println(<span class="string">"a 域类型是 TypeVariable类型！"</span>);</span><br><span class="line">            System.out.println(<span class="string">"a 域 type'name: "</span>+name);</span><br><span class="line">            <span class="keyword">for</span> (int i=0;i&lt;bounds.length;i++)&#123;</span><br><span class="line">                System.out.println(<span class="string">"a 域 type'bounds["</span>+i+<span class="string">"] Type'name: "</span>+bounds[i].getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">            GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();</span><br><span class="line">            System.out.println(<span class="string">"声明a 域变量的实体："</span>+genericDeclaration);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------------------------\n"</span>);</span><br><span class="line">        Field bField  = TypeVariableTest.class.getDeclaredField(<span class="string">"b"</span>);</span><br><span class="line">        Type bFieldType = bField.getGenericType();</span><br><span class="line">        Class bFieldClass = bField.getType();</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest&lt;T&gt; b 域 type名："</span>+bFieldType.getTypeName());</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest&lt;T&gt; b 域 type的Class名："</span>+bFieldType.getClass().getCanonicalName());</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest&lt;T&gt; b 域 Class名："</span>+bFieldClass.getCanonicalName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class TypeVariableTest&lt;T&gt; &#123;</span><br><span class="line">        T a;</span><br><span class="line">        List&lt;String&gt; b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong><em>输出结果:</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TypeVariableTest&lt;T&gt; a 域 <span class="built_in">type</span>名：T</span><br><span class="line">TypeVariableTest&lt;T&gt; a 域 <span class="built_in">type</span>的class名：sun.reflect.generics.reflectiveObjects.TypeVariableImpl</span><br><span class="line">TypeVariableTest&lt;T&gt; a 域 Class名: java.lang.Object</span><br><span class="line">a 域类型是 TypeVariable类型！</span><br><span class="line">a 域 <span class="built_in">type</span><span class="string">'name: T</span></span><br><span class="line"><span class="string">a 域 type'</span>bounds[0] Type<span class="string">'name: java.lang.Object</span></span><br><span class="line"><span class="string">声明a 域变量的实体：class Main$TypeVariableTest</span></span><br><span class="line"><span class="string">-----------------------------------------------------------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">TypeVariableTest&lt;T&gt; b 域 type名：java.util.List&lt;java.lang.String&gt;</span></span><br><span class="line"><span class="string">TypeVariableTest&lt;T&gt; b 域 type的Class名：sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span></span><br><span class="line"><span class="string">TypeVariableTest&lt;T&gt; b 域 Class名：interface java.util.List</span></span><br></pre></td></tr></table></figure></p>
<p><strong><strong>7.4 Class</strong></strong><br>Type接口的实现类，在Java中，每个.class文件在程序运行期间，都对应着一个Class对象，这个对象保存着这个类的全部信息。</p>
<p>就算是各种Type也是有它的Class对象。</p>
<p><strong><strong>7.5 WildcardType</strong></strong><br>通配符类型，例如List&lt;? extends Number&gt;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchFieldException &#123;</span><br><span class="line">        Field aField = TypeVariableTest.class.getDeclaredField(<span class="string">"a"</span>);</span><br><span class="line">        Type aFieldType = aField.getGenericType();</span><br><span class="line">        Class aFieldClass = aField.getType();</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest a 域 type名："</span>+aFieldType.getTypeName());</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest a 域 type的class名："</span>+aFieldType.getClass().getCanonicalName());</span><br><span class="line">        System.out.println(<span class="string">"TypeVariableTest a 域 Class名: "</span>+aFieldClass.getCanonicalName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aFieldType instanceof ParameterizedType)&#123;</span><br><span class="line">            ParameterizedType parameterizedType = (ParameterizedType) aFieldType;</span><br><span class="line">            System.out.println(<span class="string">"a 域Type 是 ParameterizedType ！"</span>);</span><br><span class="line">            Type[] typesString = parameterizedType.getActualTypeArguments();</span><br><span class="line">            System.out.println(<span class="string">"a 域泛型参数[0]的type名："</span>+typesString[0].getTypeName());</span><br><span class="line">            System.out.println(<span class="string">"a 域泛型参数[0]的type类型名："</span>+typesString[0].getClass().getCanonicalName());</span><br><span class="line">            </span><br><span class="line">            WildcardType type0 = (WildcardType) typesString[0];</span><br><span class="line">            Type[] type0UpperBounds = type0.getUpperBounds();</span><br><span class="line">            Type[] type0LowerBounds = type0.getLowerBounds();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"泛型参数[0]的上限type:"</span>+type0UpperBounds[0]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static class TypeVariableTest &#123;</span><br><span class="line">        List&lt;? extends String&gt; a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">TypeVariableTest a 域 <span class="built_in">type</span>名：java.util.List&lt;? extends java.lang.String&gt;</span><br><span class="line">TypeVariableTest a 域 <span class="built_in">type</span>的class名：sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl</span><br><span class="line">TypeVariableTest a 域 Class名: java.util.List</span><br><span class="line">a 域Type 是 ParameterizedType ！</span><br><span class="line">a 域泛型参数[0]的<span class="built_in">type</span>名：? extends java.lang.String</span><br><span class="line">a 域泛型参数[0]的<span class="built_in">type</span>类型名：sun.reflect.generics.reflectiveObjects.WildcardTypeImpl</span><br><span class="line">泛型参数[0]的上限<span class="built_in">type</span>:class java.lang.String</span><br></pre></td></tr></table></figure></p>
<p><strong>8.应用</strong><br>更快的读懂一些开源项目源码：几乎每个受欢迎的Java开源项目都会使用注解，反射，代理模式，适配器模式，而这些应用都需要判断Type,如果不搞懂几个Type，很容易一头雾水。<br>更好的利用Type和Java特性去设计代码</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2021/06/02/Java知识总结之——Type/" data-id="ckpf61l6a0000j4ssg8dq7fw3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-单例模式-懒汉式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/08/13/单例模式-懒汉式/" class="article-date">
  <time datetime="2020-08-13T13:01:11.000Z" itemprop="datePublished">2020-08-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/08/13/单例模式-懒汉式/">单例模式-懒汉式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>饿汉式</strong><br><strong><em>饿汉式的代码很简单也不是我们的重点。</em></strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package singleton_k;</span><br><span class="line"></span><br><span class="line">public class Computer &#123;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">Computer</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Computer computer = new Computer();</span><br><span class="line"></span><br><span class="line">    public static Computer <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>懒汉式-同步锁</strong><br>这种synchronized关键字的做法是很最简单的，但是性能较差，对象的创建实际只有一次，剩下的其实都是获取，但是却要在获取时也要同步。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package singleton_k;</span><br><span class="line"></span><br><span class="line">public class Computer2 &#123;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">Computer2</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Computer2 computer = null;</span><br><span class="line"></span><br><span class="line">    public static synchronized Computer2 <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (computer == null) &#123;</span><br><span class="line">            computer = new Computer2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>懒汉式-双检查锁</strong><br>将synchronized转移到方法中，假如有10条线程进入方法内，如果判断==null，也只能有一个线程进入同步代码块，进入代码块后再次判断是否==null第一个线程会将对象实例化。而后来的9条线程判断!=null就不会再次创建。第二次再来10条线程，则第一个if判断都不会通过，所以不会进入synchronized代码块也不会造成线程串行。大大的解决的性能问题。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package singleton_k;</span><br><span class="line"></span><br><span class="line">public class Computer3 &#123;</span><br><span class="line"></span><br><span class="line">    private String name = <span class="string">"张三"</span>;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">Computer3</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    private static  Computer3 computer = null;</span><br><span class="line"></span><br><span class="line">    public static Computer3 <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        //第二个线程判断对象不为null</span><br><span class="line">        <span class="keyword">if</span> (computer == null) &#123;</span><br><span class="line">            synchronized (Computer3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (computer == null) &#123;</span><br><span class="line">                    computer = new Computer3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这里还会有一点问题，如果在第一个线程new之后，但是没有初始化成员变量。第二个线程在第一次判断这时已经不是null了，它走到打印处，可能会没有值。所以使用volatile关键字。这个关键字的作用禁止CPU使用缓存，禁止指令重排序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package singleton_k;</span><br><span class="line"></span><br><span class="line">public class Computer3 &#123;</span><br><span class="line"></span><br><span class="line">    private String name = <span class="string">"张三"</span>;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">Computer3</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    volatile</span><br><span class="line">    作用1 禁止被他修饰变量发生指令重排序</span><br><span class="line">    作用2 禁止CPU使用缓存</span><br><span class="line">    * */</span><br><span class="line">    private static volatile Computer3 computer = null;</span><br><span class="line"></span><br><span class="line">    public static Computer3 <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">        //第二个线程判断对象不为null</span><br><span class="line">        <span class="keyword">if</span> (computer == null) &#123;</span><br><span class="line">            synchronized (Computer3.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (computer == null) &#123;</span><br><span class="line">                    /*1 new：开辟内存空间</span><br><span class="line">                     * 2 成员变量初始化</span><br><span class="line">                     * 3 将内存中的地址赋值给变量</span><br><span class="line">                     * 此处2和3可能指令重排序</span><br><span class="line">                     * */</span><br><span class="line">                    //第一个线程执行完下边这一句new出来了。</span><br><span class="line">                    computer = new Computer3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //此处可能会出错，出错了。线程1的指令重排序是132但是2还没执行就拿不到这个变量的值了</span><br><span class="line">        System.out.println(computer.name);</span><br><span class="line">        <span class="built_in">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>懒汉式-静态内部类</strong><br>通过静态内部类的方式实现单例模式是线程安全的，同时静态内部类不会在Singleton类加载时就加载，而是在调用getInstance()方法时才进行加载，达到了懒加载的效果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package singleton_k;</span><br><span class="line"></span><br><span class="line">public class Computer4 &#123;</span><br><span class="line"></span><br><span class="line">    private <span class="function"><span class="title">Computer4</span></span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    * 通过内部类维护单例JVM在类加载的时候，是互斥的，所以可以保证线程安全问题</span><br><span class="line">    * */</span><br><span class="line">    private static class Computer4Factory&#123;</span><br><span class="line">        private static Computer4 computer4 = new Computer4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Computer4 <span class="function"><span class="title">getComputer</span></span>()&#123;</span><br><span class="line">        <span class="built_in">return</span> Computer4Factory.computer4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>懒汉式-枚举</strong><br>利用枚举的特性，让JVM来帮我们保证线程安全和单一实例的问题。除此之外，写法还特别简单。<br>复制代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package singleton_k;</span><br><span class="line"></span><br><span class="line">public enum  Computer4 &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    public void <span class="function"><span class="title">show</span></span>()&#123;</span><br><span class="line">        System.out.println(<span class="string">"....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/08/13/单例模式-懒汉式/" data-id="ckpf3q7nm00096gssqgm74jeg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-分库分表的基本思想" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/05/05/分库分表的基本思想/" class="article-date">
  <time datetime="2020-05-05T02:35:08.000Z" itemprop="datePublished">2020-05-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/05/05/分库分表的基本思想/">分库分表的基本思想</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>参照：<a href="https://www.cnblogs.com/jshen/p/7682502.html" target="_blank" rel="noopener">https://www.cnblogs.com/jshen/p/7682502.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/05/05/分库分表的基本思想/" data-id="ckpf3q7ne00076gssvwel9hlq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springboot单元测试技巧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/02/21/springboot单元测试技巧/" class="article-date">
  <time datetime="2020-02-21T12:08:33.000Z" itemprop="datePublished">2020-02-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/02/21/springboot单元测试技巧/">springboot单元测试技巧</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>直奔主题：</strong></p>
<p><strong>引入依赖</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;<span class="built_in">test</span>&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>标准的Spring Boot测试单元代码结构：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class ApplicationTest &#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>JUnit4注解</strong><br>@BeforeClass、@AfterClass：在每个类加载的开始和结束时运行，必须为静态方法，执行一次。<br>@Before、@After：在每个测试方法开始之前和结束之后运行，例如Test1()和Test2()执行前后各执行一次。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class TestApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @BeforeClass</span><br><span class="line">    public static void <span class="function"><span class="title">beforeClassTest</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"before class test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    public void <span class="function"><span class="title">beforeTest</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"before test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">Test1</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"test 1+1=2"</span>);</span><br><span class="line">        Assert.assertEquals(2, 1 + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="function"><span class="title">Test2</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"test 2+2=4"</span>);</span><br><span class="line">        Assert.assertEquals(4, 2 + 2);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @After</span><br><span class="line">    public void <span class="function"><span class="title">afterTest</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"after test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @AfterClass</span><br><span class="line">    public static void <span class="function"><span class="title">afterClassTest</span></span>() &#123;</span><br><span class="line">        System.out.println(<span class="string">"after class test"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before class <span class="built_in">test</span></span><br><span class="line">before <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> 1+1=2</span><br><span class="line">after <span class="built_in">test</span></span><br><span class="line">before <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span> 2+2=4</span><br><span class="line">after <span class="built_in">test</span></span><br><span class="line">after class <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p><strong>org.junit.Assert常用方法</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assertEquals(<span class="string">"message"</span>,A,B)，判断A对象和B对象是否相等，这个判断在比较两个对象时调用了equals()方法。</span><br><span class="line">assertSame(<span class="string">"message"</span>,A,B)，判断A对象与B对象是否相同，使用的是==操作符。</span><br><span class="line">assertTrue(<span class="string">"message"</span>,A)，判断A条件是否为真。</span><br><span class="line">assertFalse(<span class="string">"message"</span>,A)，判断A条件是否不为真。</span><br><span class="line">assertNotNull(<span class="string">"message"</span>,A)，判断A对象是否不为null。</span><br><span class="line">assertArrayEquals(<span class="string">"message"</span>,A,B)，判断A数组与B数组是否相等。</span><br></pre></td></tr></table></figure></p>
<p><strong>MockMvc</strong><br>在单元测试中，使用MockMvc前需要进行初始化，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private WebApplicationContext wac;</span><br><span class="line"></span><br><span class="line">@Before</span><br><span class="line">public void <span class="function"><span class="title">setupMockMvc</span></span>()&#123;</span><br><span class="line">    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>MockMvc模拟MVC请求</strong><br>模拟一个get请求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hello?name=&#123;name&#125;"</span>,<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure></p>
<p>模拟一个post请求：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/user/&#123;id&#125;"</span>, 1));</span><br></pre></td></tr></table></figure></p>
<p>模拟文件上传：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.fileUpload(<span class="string">"/fileupload"</span>).file(<span class="string">"file"</span>, <span class="string">"文件内容"</span>.getBytes(<span class="string">"utf-8"</span>)));</span><br></pre></td></tr></table></figure></p>
<p>模拟请求参数：<br>// 模拟发送一个message参数，值为hello<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hello"</span>).param(<span class="string">"message"</span>, <span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure></p>
<p>使用MultiValueMap构建参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MultiValueMap&lt;String, String&gt; params = new LinkedMultiValueMap&lt;String, String&gt;();</span><br><span class="line">params.add(<span class="string">"name"</span>, <span class="string">"Tom"</span>);</span><br><span class="line">params.add(<span class="string">"moblie"</span>, <span class="string">"123"</span>);</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/hobby/save"</span>).params(params));</span><br></pre></td></tr></table></figure></p>
<p>模拟发送JSON参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String jsonStr = <span class="string">"&#123;\"username\":\"Dopa\",\"passwd\":\"ac3af72d9f95161a502fd326865c2f15\",\"status\":\"1\"&#125;"</span>;</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/user/save"</span>).content(jsonStr.getBytes()));</span><br></pre></td></tr></table></figure></p>
<p>实际测试中，要手动编写这么长的JSON格式字符串很繁琐也很容易出错，可以借助Spring Boot自带的Jackson技术来序列化一个Java对象,如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User user = new User();</span><br><span class="line">user.setUsername(<span class="string">"Dopa"</span>);</span><br><span class="line">user.setPasswd(<span class="string">"ac3af72d9f95161a502fd326865c2f15"</span>);</span><br><span class="line">user.setStatus(<span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">String userJson = mapper.writeValueAsString(user);</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/user/save"</span>).content(userJson.getBytes()));</span><br></pre></td></tr></table></figure></p>
<p>其中，mapper为com.fasterxml.jackson.databind.ObjectMapper对象。</p>
<p>模拟Session和Cookie：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>).sessionAttr(name, value));</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>).cookie(new Cookie(name, value)));</span><br></pre></td></tr></table></figure></p>
<p>设置请求的Content-Type：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>).contentType(MediaType.APPLICATION_JSON_UTF8));</span><br></pre></td></tr></table></figure></p>
<p>设置返回格式为JSON：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/user/&#123;id&#125;"</span>, 1).accept(MediaType.APPLICATION_JSON));</span><br></pre></td></tr></table></figure></p>
<p>模拟HTTP请求头：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/user/&#123;id&#125;"</span>, 1).header(name, values));</span><br></pre></td></tr></table></figure></p>
<p>MockMvc处理返回结果<br>期望成功调用，即HTTP Status为200：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/user/&#123;id&#125;"</span>, 1))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.status().isOk());</span><br><span class="line">```    </span><br><span class="line">期望返回内容是application/json：</span><br><span class="line">```bash</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/user/&#123;id&#125;"</span>, 1))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON));</span><br><span class="line">```    </span><br><span class="line">检查返回JSON数据中某个值的内容：</span><br><span class="line">```bash</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/user/&#123;id&#125;"</span>, 1))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"$.username"</span>).value(<span class="string">"Tom"</span>));</span><br><span class="line">```    </span><br><span class="line">这里使用到了jsonPath，$代表了JSON的根节点。更多关于jsonPath的介绍可参考 https://github.com/json-path/JsonPath。</span><br><span class="line">判断Controller方法是否返回某视图：</span><br><span class="line">```bash            </span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.post(<span class="string">"/index"</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.view().name(<span class="string">"index.html"</span>));</span><br></pre></td></tr></table></figure></p>
<p>比较Model：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/user/&#123;id&#125;"</span>, 1))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.model().size(1))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.model().attributeExists(<span class="string">"password"</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.model().attribute(<span class="string">"username"</span>, <span class="string">"Tom"</span>));</span><br><span class="line">```    </span><br><span class="line">比较forward或者redirect：</span><br><span class="line">```bash</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.forwardedUrl(<span class="string">"index.html"</span>));</span><br><span class="line">```    </span><br><span class="line">// 或者</span><br><span class="line">```bash</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.redirectedUrl(<span class="string">"index.html"</span>));</span><br></pre></td></tr></table></figure></p>
<p>比较返回内容，使用content()：<br>// 返回内容为hello<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().string(<span class="string">"hello"</span>));</span><br></pre></td></tr></table></figure></p>
<p>// 返回内容是XML，并且与xmlCotent一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().xml(xmlContent));</span><br></pre></td></tr></table></figure></p>
<p>// 返回内容是JSON ，并且与jsonContent一样<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>))</span><br><span class="line">    .andExpect(MockMvcResultMatchers.content().json(jsonContent));</span><br><span class="line">```    </span><br><span class="line">输出响应结果：</span><br><span class="line">```bash</span><br><span class="line">mockMvc.perform(MockMvcRequestBuilders.get(<span class="string">"/index"</span>))</span><br><span class="line">    .andDo(MockMvcResultHandlers.print());</span><br><span class="line">```    </span><br><span class="line"><span class="comment">####测试Service</span></span><br><span class="line">Service代码：</span><br><span class="line">```bash</span><br><span class="line">@Repository(<span class="string">"userService"</span>)</span><br><span class="line">public class UserServiceImpl extends BaseService&lt;User&gt; implements UserService &#123;</span><br><span class="line">   ...</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在测试方法上加上@Transactional注，数据能自动回滚<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    @Transactional</span><br><span class="line">    public void <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(<span class="string">"Junit"</span>);</span><br><span class="line">        user.setPasswd(<span class="string">"123456"</span>);</span><br><span class="line">        user.setStatus(<span class="string">"1"</span>);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        this.userService.save(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试通过，查看数据库发现数据并没有被插入，这样很好的避免了不必要的数据污染。   </p>
<p>####测试Controller<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(<span class="string">"user/&#123;userName&#125;"</span>)</span><br><span class="line">    public User getUserByName(@PathVariable(value = <span class="string">"userName"</span>) String userName) &#123;</span><br><span class="line">        <span class="built_in">return</span> this.userService.findByName(userName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(<span class="string">"user/save"</span>)</span><br><span class="line">    public void saveUser(@RequestBody User user) &#123;</span><br><span class="line">        this.userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>getUserByName(@PathVariable(value = “userName”) String userName)方法的测试类<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext wac;</span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    public void <span class="function"><span class="title">setupMockMvc</span></span>()&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Test</span><br><span class="line">    public void <span class="built_in">test</span>() throws Exception &#123;</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">            MockMvcRequestBuilders.get(<span class="string">"/user/&#123;userName&#125;"</span>, <span class="string">"scott"</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON_UTF8))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">        .andExpect(MockMvcResultMatchers.jsonPath(<span class="string">"$.username"</span>).value(<span class="string">"scott"</span>))</span><br><span class="line">        .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>saveUser(@RequestBody User user)方法的测试类：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserControllerTest &#123;</span><br><span class="line"></span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    private WebApplicationContext wac;</span><br><span class="line">    </span><br><span class="line">    @Autowired</span><br><span class="line">    ObjectMapper mapper;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    @Before</span><br><span class="line">    public void <span class="function"><span class="title">setupMockMvc</span></span>()&#123;</span><br><span class="line">        mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    @Test</span><br><span class="line">    @Transactional</span><br><span class="line">    public void <span class="built_in">test</span>() throws Exception &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setUsername(<span class="string">"Dopa"</span>);</span><br><span class="line">        user.setPasswd(<span class="string">"ac3af72d9f95161a502fd326865c2f15"</span>);</span><br><span class="line">        user.setStatus(<span class="string">"1"</span>);</span><br><span class="line">        </span><br><span class="line">        String userJson = mapper.writeValueAsString(user);</span><br><span class="line">        mockMvc.perform(</span><br><span class="line">            MockMvcRequestBuilders.post(<span class="string">"/user/save"</span>)</span><br><span class="line">            .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">            .content(userJson.getBytes()))</span><br><span class="line">        .andExpect(MockMvcResultMatchers.status().isOk())</span><br><span class="line">        .andDo(MockMvcResultHandlers.print());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>单元测试时模拟一个登录用户信息Session，MockMvc也提供了解决方案，可在初始化的时候模拟一个HttpSession：</p>
<pre><code class="bash">private MockMvc mockMvc;
private MockHttpSession session;

@Autowired
private WebApplicationContext wac;

@Before
public void <span class="function"><span class="title">setupMockMvc</span></span>(){
    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build();
    session = new MockHttpSession();
    User user =new User();
    user.setUsername(<span class="string">"Dopa"</span>);
    user.setPasswd(<span class="string">"ac3af72d9f95161a502fd326865c2f15"</span>);
    session.setAttribute(<span class="string">"user"</span>, user); 
}
</code></pre>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/02/21/springboot单元测试技巧/" data-id="ckpf3q7op000g6gss9j4fwpvg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-全面剖析redis Cluster(redis集群)原理和应用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/02/16/全面剖析redis Cluster(redis集群)原理和应用/" class="article-date">
  <time datetime="2020-02-16T08:10:13.000Z" itemprop="datePublished">2020-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/02/16/全面剖析redis Cluster(redis集群)原理和应用/">全面剖析redis Cluster(redis集群)原理和应用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>详情参照：<a href="https://www.cnblogs.com/softidea/p/5365653.html" target="_blank" rel="noopener">https://www.cnblogs.com/softidea/p/5365653.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/02/16/全面剖析redis Cluster(redis集群)原理和应用/" data-id="ckpf3q7nb00066gssw66zitau" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-简述Spring的ApplicationEvent使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/02/14/简述Spring的ApplicationEvent使用/" class="article-date">
  <time datetime="2020-02-14T05:46:33.000Z" itemprop="datePublished">2020-02-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/02/14/简述Spring的ApplicationEvent使用/">简述Spring的ApplicationEvent使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>spring 事件为bean 与 bean之间传递消息。一个bean处理完了希望其余一个接着处理.这时我们就需要其余的一个bean监听当前bean所发送的事件.<br>spring事件使用步骤如下:</p>
<p>1.先自定义事件：你的事件需要继承 ApplicationEvent</p>
<p>2.定义事件监听器: 需要实现 ApplicationListener</p>
<p>3.使用容器对事件进行发布</p>
<p>首先定义一个事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class TestEvent extends ApplicationEvent &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String msg;</span><br><span class="line"></span><br><span class="line">    public TestEvent(Object <span class="built_in">source</span>)&#123;</span><br><span class="line">        super(<span class="built_in">source</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TestEvent(Object <span class="built_in">source</span>, String name, String msg) &#123;</span><br><span class="line">        super(<span class="built_in">source</span>);</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getName</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String <span class="function"><span class="title">getMsg</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMsg(String msg) &#123;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其次定义事件监听<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestEventListener implements ApplicationListener&lt;TestEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(TestEvent testEvent) &#123;</span><br><span class="line">        System.out.println(<span class="string">"姓名："</span>+testEvent.getName()+<span class="string">"得到消息："</span>+testEvent.getMsg());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用容器发布事件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class TestEventPublisher &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    public void pushlish(String name, String msg)&#123;</span><br><span class="line">        applicationContext.publishEvent(new TestEvent(this, name,msg));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试事件是否能够生效<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ComponentScan(<span class="string">"cn.*.event"</span>)</span><br><span class="line">public class EventConfig &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestMain &#123;</span><br><span class="line"></span><br><span class="line">    private static AnnotationConfigApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void <span class="function"><span class="title">start</span></span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (context == null) &#123;</span><br><span class="line">             context=new AnnotationConfigApplicationContext(EventConfig.class);</span><br><span class="line">        &#125;</span><br><span class="line">        context.getBean(TestEventPublisher.class).pushlish(<span class="string">"hangyu"</span>,<span class="string">"申请退款！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/02/14/简述Spring的ApplicationEvent使用/" data-id="ckpf3q7oz000k6gsshr6adqpq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解幂等性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/02/11/深入理解幂等性/" class="article-date">
  <time datetime="2020-02-11T08:21:00.000Z" itemprop="datePublished">2020-02-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/02/11/深入理解幂等性/">深入理解幂等性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>什么是幂等性</strong><br>HTTP/1.1中对幂等性的定义是：一次和多次请求某一个资源对于资源本身应该具有同样的结果（网络超时等问题除外）。也就是说，其任意多次执行对资源本身所产生的影响均与一次执行的影响相同。<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Methods can also have the property of “idempotence” <span class="keyword">in</span> that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as <span class="keyword">for</span> a single request.</span><br></pre></td></tr></table></figure></p>
<p> 这里需要关注几个重点：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">幂等不仅仅只是一次（或多次）请求对资源没有副作用（比如查询数据库操作，没有增删改，因此没有对数据库有任何影响）。</span><br><span class="line"> </span><br><span class="line">幂等还包括第一次请求的时候对资源产生了副作用，但是以后的多次请求都不会再对资源产生副作用。</span><br><span class="line"> </span><br><span class="line">幂等关注的是以后的多次请求是否对资源产生的副作用，而不关注结果。</span><br><span class="line"> </span><br><span class="line">网络超时等问题，不是幂等的讨论范围。</span><br></pre></td></tr></table></figure></p>
<p> 幂等性是系统服务对外一种承诺（而不是实现），承诺只要调用接口成功，外部多次调用对系统的影响是一致的。声明为幂等的服务会认为外部调用失败是常态，并且失败之后必然会有重试。</p>
<p> <strong>什么情况下需要幂等</strong><br> 业务开发中，经常会遇到重复提交的情况，无论是由于网络问题无法收到请求结果而重新发起请求，或是前端的操作抖动而造成重复提交情况。 在交易系统，支付系统这种重复提交造成的问题有尤其明显，比如：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户在APP上连续点击了多次提交订单，后台应该只产生一个订单；</span><br><span class="line"> </span><br><span class="line">向支付宝发起支付请求，由于网络问题或系统BUG重发，支付宝应该只扣一次钱。 很显然，声明幂等的服务认为，外部调用者会存在多次调用的情况，为了防止外部多次调用对系统数据状态的发生多次改变，将服务设计成幂等。</span><br></pre></td></tr></table></figure></p>
<p><strong>幂等VS防重</strong><br>上面例子中小明遇到的问题，只是重复提交的情况，和服务幂等的初衷是不同的。重复提交是在第一次请求已经成功的情况下，人为的进行多次操作，导致不满足幂等要求的服务多次改变状态。而幂等更多使用的情况是第一次请求不知道结果（比如超时）或者失败的异常情况下，发起多次请求，目的是多次确认第一次请求成功，却不会因多次请求而出现多次的状态变化。</p>
<p><strong>什么情况下需要保证幂等性</strong><br>以SQL为例，有下面三种场景，只有第三种场景需要开发人员使用其他策略保证幂等性：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT col1 FROM tab1 WHER col2=2，无论执行多少次都不会改变状态，是天然的幂等。</span><br><span class="line"></span><br><span class="line">UPDATE tab1 SET col1=1 WHERE col2=2，无论执行成功多少次状态都是一致的，因此也是幂等操作。</span><br><span class="line"></span><br><span class="line">UPDATE tab1 SET col1=col1+1 WHERE col2=2，每次执行的结果都会发生变化，这种不是幂等的。</span><br></pre></td></tr></table></figure></p>
<p><strong>为什么要设计幂等性的服务</strong><br>幂等可以使得客户端逻辑处理变得简单，但是却以服务逻辑变得复杂为代价。满足幂等服务的需要在逻辑中至少包含两点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先去查询上一次的执行状态，如果没有则认为是第一次请求</span><br><span class="line"></span><br><span class="line">在服务改变状态的业务逻辑前，保证防重复提交的逻辑</span><br></pre></td></tr></table></figure></p>
<p><strong>幂等的不足</strong><br>幂等是为了简化客户端逻辑处理，却增加了服务提供者的逻辑和成本，是否有必要，需要根据具体场景具体分析，因此除了业务上的特殊要求外，尽量不提供幂等的接口。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">增加了额外控制幂等的业务逻辑，复杂化了业务功能；</span><br><span class="line"></span><br><span class="line">把并行执行的功能改为串行执行，降低了执行效率。</span><br></pre></td></tr></table></figure></p>
<p><strong>保证幂等策略</strong><br>幂等需要通过唯一的业务单号来保证。也就是说相同的业务单号，认为是同一笔业务。使用这个唯一的业务单号来确保，后面多次的相同的业务单号的处理逻辑和执行效果是一致的。 下面以支付为例，在不考虑并发的情况下，实现幂等很简单：①先查询一下订单是否已经支付过，②如果已经支付过，则返回支付成功；如果没有支付，进行支付流程，修改订单状态为‘已支付’。</p>
<p><strong>防重复提交策略(select+insert)</strong><br>上述的保证幂等方案是分成两步的，第②步依赖第①步的查询结果，无法保证原子性的。在高并发下就会出现下面的情况：第二次请求在第一次请求第②步订单状态还没有修改为‘已支付状态’的情况下到来。既然得出了这个结论，余下的问题也就变得简单：把查询和变更状态操作加锁，将并行操作改为串行操作。</p>
<p><strong>乐观锁</strong><br>如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。例如： UPDATE tab1 SET col1=1,version=version+1 WHERE version=#version# 不过，乐观锁存在失效的情况，就是常说的ABA问题，不过如果version版本一直是自增的就不会出现ABA的情况。（从网上找了一张图片很能说明乐观锁，引用过来，出自Mybatis对乐观锁的支持） </p>
<p><strong>悲观锁</strong><br>获取数据的时候加锁获取：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table <span class="built_in">where</span> id = <span class="string">'xxx'</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure></p>
<p>要注意的是，id字段一定要是主键或者唯一索引，否则会导致锁表。<br>悲观锁的使用一般伴随事务一起使用，数据锁定事件可能会很长，要根据实际情况慎用</p>
<p><strong>防重表</strong><br>使用订单号orderNo做为去重表的唯一索引，每次请求都根据订单号向去重表中插入一条数据。第一次请求查询订单支付状态，当然订单没有支付，进行支付操作，无论成功与否，执行完后更新订单状态为成功或失败，删除去重表中的数据。后续的订单因为表中唯一索引而插入失败，则返回操作失败，直到第一次的请求完成（成功或失败）。可以看出防重表作用是加锁的功能。</p>
<p><strong>分布式锁</strong><br>这里使用的防重表可以使用分布式锁代替，比如Redis。订单发起支付请求，支付系统会去Redis缓存中查询是否存在该订单号的Key，如果不存在，则向Redis增加Key为订单号。查询订单支付已经支付，如果没有则进行支付，支付完成后删除该订单号的Key。通过Redis做到了分布式锁，只有这次订单订单支付请求完成，下次请求才能进来。相比去重表，将放并发做到了缓存中，较为高效。思路相同，同一时间只能完成一次支付请求。 </p>
<p><strong>Token机制，防止页面重复提交</strong><br>页面数据只能够提交一次，但是由于出现重复点击或者网络重发或Nginx重发等情况导致数据被重复提交的情况下，可以采用Token+Redis（Redis是单线程的，处理需要排队）的解决方案。处理的流程是，在数据提交前要向服务器申请带有有效时间的Token，然后Token放到Redis或JVM内存中，当数据正式提交到后台要校验Token并删除Token。 </p>
<p><strong>支付缓冲区</strong><br>把订单的支付请求都快速地接下来，一个快速接单的缓冲管道。后续使用异步任务处理管道中的数据，过滤掉重复的待支付订单。优点是同步转异步，高吞吐。不足是不能及时地返回支付结果，需要后续监听支付结果的异步返回。    </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/02/11/深入理解幂等性/" data-id="ckpf3q7og000d6gss47n1gnr2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解CAS算法原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/02/10/深入理解CAS算法原理/" class="article-date">
  <time datetime="2020-02-10T06:10:23.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/02/10/深入理解CAS算法原理/">深入理解CAS算法原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>​1、什么是CAS？</p>
<p>CAS：Compare and Swap，即比较再交换。</p>
<p>jdk5增加了并发包java.util.concurrent.*,其下面的类使用CAS算法实现了区别于synchronouse同步锁的一种乐观锁。JDK 5之前Java语言是靠synchronized关键字保证同步的，这是一种独占锁，也是是悲观锁。</p>
<p>2、CAS算法理解</p>
<p>对CAS的理解，CAS是一种无锁算法，CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<hr>
<p>详情参照：<a href="https://www.jianshu.com/p/21be831e851e" target="_blank" rel="noopener">https://www.jianshu.com/p/21be831e851e</a></p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/02/10/深入理解CAS算法原理/" data-id="ckpf3q7ny000c6gssijc88j2a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-volatile详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/02/10/volatile详解/" class="article-date">
  <time datetime="2020-02-10T04:08:44.000Z" itemprop="datePublished">2020-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/02/10/volatile详解/">volatile详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一、volatile简介</strong><br>在单线程环境中，我们几乎用不到这个关键词，但是多线程环境中，这个关键词随处可见。总的来说，volatile有以下三个特性：</p>
<p>保证可见性；<br>不保证原子性；<br>禁止指令重排。<br>下面就来详细的说说这三个特性。<br><strong>二、保证可见性</strong><br><strong>1、什么是可见性？</strong><br>在说volatile保证可见性之前，先来说说什么叫可见性。谈到可见性，又不得不说JMM(java memory model)内存模型。JMM内存模型是逻辑上的划分，及并不是真实存在。Java线程之间的通信就由JMM控制。</p>
<p>我们定义的共享变量，是存储在主内存中的，也就是计算机的内存条中。线程A去操作共享变量的时候，并不能直接操作主内存中的值，而是将主内存中的值拷贝回自己的工作内存中，在工作内存中做修改。修改好后，在将值刷回到主内存中。</p>
<p>假设现在new 一个 student , age为 18，这个18是存储在主内存中的。现在两个线程先将18拷贝回自己的工作内存中。这时，A线程将18改为了20，刷回到主内存中。也就是说，现在主内存中的值变为了20。可是，B线程并不知道现在主内存中的值变了，因为A线程所做的操作对B是不可见的。我们需要一种机制，即一旦主内存中的值发生改变，就及时地通知所有的线程，保证他们对这个变化可见。这就是可见性。我们通常用happen - before(先行发生原则)，来阐述操作之间内存的可见性。也就是前一个的操作结果对后一个操作可见，那么这两个操作就存在 happen - before 规则。</p>
<p><strong>2、为什么volatile能保证可见性？</strong><br>先来说一说内存屏障(memory barrier)，这是一条CPU指令，可以影响数据的可见性。当变量用volatile修饰时，将会在写操作的后面加一条屏障指令，在读操作的前面加一条屏障指令。这样的话，一旦你写入完成，可以保证其他线程读到最新值，也就保证了可见性。</p>
<p><strong>3、验证volatile保证可见性。</strong><br>验证volatile可见性和不保证原子性的代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 验证可见性</span><br><span class="line">class MyData &#123;</span><br><span class="line">    //int number = 0; // 没加volatile关键字</span><br><span class="line">    volatile int number = 0;</span><br><span class="line">    int <span class="function"><span class="title">changeNumber</span></span>() &#123;</span><br><span class="line">        <span class="built_in">return</span> this.number = 60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class VolatileTest &#123;</span><br><span class="line">    // 验证可见性</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        MyData myData = new MyData();</span><br><span class="line">        new Thread(<span class="string">"AAA"</span>) &#123;</span><br><span class="line">            public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(3000);</span><br><span class="line">                    // 睡3秒后调用changeNumber方法将number改为60</span><br><span class="line">                    System.err.println(Thread.currentThread().getName() </span><br><span class="line">                                        +  <span class="string">" update number to "</span> + myData.changeNumber());</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        // 主线程</span><br><span class="line">        <span class="keyword">while</span> (myData.number == 0) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果主线程读取到的一直都是最开始的0，</span><br><span class="line">        //将造成死循环，这句话将无法输出</span><br><span class="line">        System.err.println(Thread.currentThread().getName() </span><br><span class="line">                          + <span class="string">" get number value is "</span> + myData.number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码很简单，定义了一个MyData类，初始一个number，值为0。然后在main方法中创建另一个线程，将其值改为60。但是，这个线程对number所作的操作对main线程是不可见的，所以main线程以为number还是0，因此，将会造成死循环。如果number加了volatile修饰，main线程就可以获取到主内存中的最新值，就不会死循环。这就验证了volatile可以保证可见性。</p>
<p><strong>三、不保证原子性</strong><br><strong>1、什么叫原子性？</strong><br>所谓原子性，就是说一个操作不可被分割或加塞，要么全部执行，要么全不执行。</p>
<p><strong>2、volatile不保证原子性解析</strong><br>java程序在运行时，JVM将java文件编译成了class文件。我们使用javap命令对class文件进行反汇编，就可以查看到java编译器生成的字节码。最常见的 i++ 问题，其实 反汇编后是分三步进行的。</p>
<p>第一步：将i的初始值装载进工作内存；<br>第二步：在自己的工资内存中进行自增操作；<br>第三步：将自己工作内存的值刷回到主内存。<br>我们知道线程的执行具有随机性，假设现在i的初始值为0，有A和B两个线程对其进行++操作。首先两个线程将0拷贝到自己工作内存，当线程A在自己工作内存中进行了自增变成了1，还没来得及把1刷回到主内存，这是B线程抢到CPU执行权了。B将自己工作内存中的0进行自增，也变成了1。然后线程A将1刷回主内存，主内存此时变成了1，然后B也将1刷回主内存，主内存中的值还是1。本来A和B都对i进行了一次自增，此时主内存中的值应该是2，而结果是1，出现了写丢失的情况。这是因为i++本应该是一个原子操作，但是却被加塞了其他操作。所以说volatile不保证原子性。</p>
<p><strong>3、volatile不保证原子性验证</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 验证volatile不保证原子性</span><br><span class="line">   void  <span class="function"><span class="title">addPlusPlus</span></span>() &#123;</span><br><span class="line">       this.number++;</span><br><span class="line">   &#125;</span><br><span class="line">   // 验证volatile不保证原子性</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">       MyData mydata2 = new MyData();</span><br><span class="line">       <span class="keyword">for</span>(int i = 0; i &lt; 20; i ++ ) &#123; // 创建20个线程</span><br><span class="line">           new Thread(<span class="string">"线程"</span> + i) &#123;</span><br><span class="line">               public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">                   try &#123;</span><br><span class="line">                       <span class="keyword">for</span>(int j = 0; j &lt; 1000; j++) &#123;</span><br><span class="line">                           mydata2.addPlusPlus();// 每个线程执行1000次number++</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;;</span><br><span class="line">           &#125;.start();</span><br><span class="line">       &#125;</span><br><span class="line">       // 保证上面的线程执行完main线程再输出结果。 大于2，因为默认有main线程和gc线程</span><br><span class="line">       <span class="keyword">while</span>(Thread.activeCount() &gt; 2) &#123;</span><br><span class="line">           Thread.yield();</span><br><span class="line">       &#125;</span><br><span class="line">       System.err.println(Thread.currentThread().getName() + <span class="string">" obtain the number is "</span> + mydata2.number);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>同样是上面的MyData类，有一个volatile修饰的number变量初始值为0。现在有20个线程，每个线程对其执行1000次++操作。理论上执行完后，main线程输出的结果是20000，但是运行之后会发现，每次的运行结果都会小于20000，这就是因为出现了写丢失的情况。<br>解决办法：</p>
<p>第一种：可以在addPlusPlus方法中加synchronized；<br>第二种：可以使用原子包装类AtomicInteger。<br>第一种办法不太好，因为synchronized太重量级了，整个操作都加锁了。第二种办法更好。但是为什么AtomicInteger就可以保证原子性呢？因为它使用了CAS算法。什么是CAS？后续我再专门写一篇介绍CAS的文章。</p>
<p><strong>三、禁止指令重排</strong><br><strong>1、什么叫指令重排？</strong><br>上面说了，使用javap命令可以对class文件进行反汇编，查看到程序底层到底是如何执行的。像 i++ 这样一个简单的操作，底层就分三步执行。在多线程情况下，计算机为了提高执行效率，就会对这些步骤进行重排序，这就叫指令重排。比如现有如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 1;</span><br><span class="line">int y = 2;</span><br><span class="line">x = x + 3;</span><br><span class="line">y = x - 4;</span><br></pre></td></tr></table></figure>
<p>这四条语句，正常的执行顺序是从上往下1234这样执行，x的结果应该是4，y的结果应该是0。但是在多线程环境中，编译器指令重排后，执行顺序可能就变成了1243，这样得出的x就是4，y就是-3，这结果显然就不正确了。不过编译器在重排的时候也会考虑数据的依赖性，比如执行顺序不可能为2413，因为第4条语句的执行是依赖x的。使用volatile修饰，就可以禁止指令重排。</p>
<p><strong>四、你在哪些地方使用过volatile？</strong></p>
<p>最经典的就是单例模式。</p>
<p>最简版单例模式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private static SingletonDemo  singletonDemo = null;</span><br><span class="line">    private <span class="function"><span class="title">SingletonDemo</span></span>()&#123;</span><br><span class="line">        System.err.println(<span class="string">"构造方法被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonDemo <span class="function"><span class="title">getInstance</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo == null)&#123;</span><br><span class="line">            singletonDemo = new SingletonDemo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是我们最开始学的时候写的单例模式。看似很完美。其实多线程环境中就会出问题。测试一下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = 0; i &lt;= 10; i++)&#123;</span><br><span class="line">           new Thread(() -&gt; SingletonDemo.getInstance()).start();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>10个线程去执行这个单例，看结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">构造方法被执行</span><br><span class="line">构造方法被执行</span><br><span class="line"></span><br><span class="line">Process finished with <span class="built_in">exit</span> code 0</span><br></pre></td></tr></table></figure></p>
<p>构造方法被执行这句话打印了两次，说明创建了两次对象。所以在多线程环境中这个单例模式是有问题的。可以在getInstance方法上加synchronized，但是，这样就把一整个方法都锁了，这样不太好。下面介绍另一种方式。</p>
<p><strong>DCL版单例模式：</strong><br>DCL，是double check lock 的缩写，中文名叫双端检索机制。所谓双端检索，就是在加锁前和加锁后都用进行一次判断。代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private static SingletonDemo  singletonDemo = null;</span><br><span class="line">    private <span class="function"><span class="title">SingletonDemo</span></span>()&#123;</span><br><span class="line">        System.err.println(<span class="string">"构造方法被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonDemo <span class="function"><span class="title">getInstance</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo == null)&#123; // 第一次check</span><br><span class="line">            synchronized (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonDemo == null) // 第二次check</span><br><span class="line">                    singletonDemo = new SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p> 用synchronized只锁住创建实例那部分代码，而不是整个方法。在加锁前和加锁后都进行判断，这就叫双端检索机制。经测试，这样确实只创建了一个对象。但是，这也并非绝对安全。new 一个对象也是分三步的：</p>
<p> 1.分配对象内存空间；(这个房间有人订了)<br> 2.初始化对象；(打扫好房间)<br> 3.将对象指向分配的内存地址，此时这个对象不为null。(订房间的人入住)<br> 步骤二和步骤三不存在数据依赖，因此编译器优化时允许这两句颠倒顺序。当指令重拍后，多线程去访问也会出问题。所以便有了如下的最终版单例模式。</p>
<p> <strong>最终版单例模式：</strong><br> 既然说到DCL版可能会出现指令重排的现象，所以最终版就是加上volatile。<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class SingletonDemo &#123;</span><br><span class="line">    private static volatile SingletonDemo  singletonDemo = null;</span><br><span class="line">    private <span class="function"><span class="title">SingletonDemo</span></span>()&#123;</span><br><span class="line">        System.err.println(<span class="string">"构造方法被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    public static SingletonDemo <span class="function"><span class="title">getInstance</span></span>()&#123;</span><br><span class="line">        <span class="keyword">if</span> (singletonDemo == null)&#123; // 第一次check</span><br><span class="line">            synchronized (SingletonDemo.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (singletonDemo == null) // 第二次check</span><br><span class="line">                    singletonDemo = new SingletonDemo();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> singletonDemo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>总结：</strong><br> <strong>1、volatile特性：</strong></p>
<p>  可见性<br>  不保证原子性<br>  禁止指令重排<br> <strong>2、volatile的应用：</strong><br>  最经典的就是单例模式。</p>
<p>  原文地址：<a href="https://www.jianshu.com/p/b05e4da39de9" target="_blank" rel="noopener">https://www.jianshu.com/p/b05e4da39de9</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/02/10/volatile详解/" data-id="ckpf3q7os000h6gssp4z0xcvm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-idea配置查看代码汇编指令插件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/my-blogs/2020/02/05/idea配置查看代码汇编指令插件/" class="article-date">
  <time datetime="2020-02-05T15:22:59.000Z" itemprop="datePublished">2020-02-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/my-blogs/2020/02/05/idea配置查看代码汇编指令插件/">idea配置查看代码汇编指令插件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一、工具</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hsdis-amd64.dll</span><br><span class="line">hsdis-amd64.lib</span><br></pre></td></tr></table></figure></p>
<p><strong>二.开始配置：</strong></p>
<ol>
<li>将上述两个文件放在你的 jre/bin 路径下的路径里。<br>2.去idea 去配置启动参数：-server -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:CompileCommand=compileonly,<em>ClassName.method（</em>后面配置成自己的 “类名.方法名”)<br>3.设置jre路径为配置过的jre路径</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://zzy896.github.io/my-blogs/2020/02/05/idea配置查看代码汇编指令插件/" data-id="ckpf3q7n500046gssn0kv1ts0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/my-blogs/page/2/">2</a><a class="page-number" href="/my-blogs/page/3/">3</a><a class="extend next" rel="next" href="/my-blogs/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/my-blogs/archives/2019/06/">June 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/my-blogs/2021/06/02/Java知识总结之——Type/">Java知识总结之——Type</a>
          </li>
        
          <li>
            <a href="/my-blogs/2020/08/13/单例模式-懒汉式/">单例模式-懒汉式</a>
          </li>
        
          <li>
            <a href="/my-blogs/2020/05/05/分库分表的基本思想/">分库分表的基本思想</a>
          </li>
        
          <li>
            <a href="/my-blogs/2020/02/21/springboot单元测试技巧/">springboot单元测试技巧</a>
          </li>
        
          <li>
            <a href="/my-blogs/2020/02/16/全面剖析redis Cluster(redis集群)原理和应用/">全面剖析redis Cluster(redis集群)原理和应用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2021 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/my-blogs/" class="mobile-nav-link">Home</a>
  
    <a href="/my-blogs/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/my-blogs/fancybox/jquery.fancybox.css">
  <script src="/my-blogs/fancybox/jquery.fancybox.pack.js"></script>


<script src="/my-blogs/js/script.js"></script>



  </div>
</body>
</html>